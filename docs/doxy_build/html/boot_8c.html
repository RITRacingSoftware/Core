<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Core: /home/matthias/racing/core/src/driver/Src/boot.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="register_tables.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Core
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_4db3a2f7aa3a8b9901e70dfeb2571af9.html">driver</a></li><li class="navelem"><a class="el" href="dir_bd43694d282a1a6821503b447b4f5643.html">Src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">boot.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Core bootloader.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;usart.h&quot;</code><br />
<code>#include &quot;gpio.h&quot;</code><br />
<code>#include &quot;clock.h&quot;</code><br />
<code>#include &quot;can.h&quot;</code><br />
<code>#include &quot;error_handler.h&quot;</code><br />
<code>#include &quot;core_config.h&quot;</code><br />
<code>#include &quot;stm32g4xx_hal.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a493d540465c602715c436346fee5448d"><td class="memItemLeft" align="right" valign="top"><a id="a493d540465c602715c436346fee5448d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOTSTART</b>&#160;&#160;&#160;<a class="el" href="boot_8c.html#afd4a6162138d796e34cee4d8a2442596">__attribute__</a> ((section (&quot;.bootstart&quot;))) __attribute__ ((__used__))</td></tr>
<tr class="separator:a493d540465c602715c436346fee5448d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c90e3d19ed94dfa33b60685c7428c77"><td class="memItemLeft" align="right" valign="top"><a id="a7c90e3d19ed94dfa33b60685c7428c77"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOTSTATE</b>&#160;&#160;&#160;<a class="el" href="boot_8c.html#afd4a6162138d796e34cee4d8a2442596">__attribute__</a> ((section (&quot;.bootstate&quot;)))</td></tr>
<tr class="separator:a7c90e3d19ed94dfa33b60685c7428c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29693d620c6ad33c3355b5a50551c3e6"><td class="memItemLeft" align="right" valign="top"><a id="a29693d620c6ad33c3355b5a50551c3e6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ALTBANK_BASE</b>&#160;&#160;&#160;0x08040000</td></tr>
<tr class="separator:a29693d620c6ad33c3355b5a50551c3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f24a8a30c822a9eba74b5f85891682"><td class="memItemLeft" align="right" valign="top"><a id="a04f24a8a30c822a9eba74b5f85891682"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOT_STATE_KEY</b>&#160;&#160;&#160;0xABCDEF00</td></tr>
<tr class="separator:a04f24a8a30c822a9eba74b5f85891682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130489ae854e12b78d240992ae15f796"><td class="memItemLeft" align="right" valign="top"><a id="a130489ae854e12b78d240992ae15f796"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOT_STATE_NORMAL</b>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:a130489ae854e12b78d240992ae15f796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d1df504d3cd4ea0573d7345547a186"><td class="memItemLeft" align="right" valign="top"><a id="a19d1df504d3cd4ea0573d7345547a186"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOT_STATE_VERIFY</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:a19d1df504d3cd4ea0573d7345547a186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374ddab2f5e387e175db32effcab51da"><td class="memItemLeft" align="right" valign="top"><a id="a374ddab2f5e387e175db32effcab51da"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOT_STATE_VERIFY_SOFT_SWITCH</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:a374ddab2f5e387e175db32effcab51da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7c831ec055ef3ff25889b6a656dca6"><td class="memItemLeft" align="right" valign="top"><a id="a9b7c831ec055ef3ff25889b6a656dca6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOT_STATE_SOFT_SWITCHED</b>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:a9b7c831ec055ef3ff25889b6a656dca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6467331ede146fbd11dcb1005501762d"><td class="memItemLeft" align="right" valign="top"><a id="a6467331ede146fbd11dcb1005501762d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOT_STATE_VERIFIED</b>&#160;&#160;&#160;0x08</td></tr>
<tr class="separator:a6467331ede146fbd11dcb1005501762d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f0b8e9500ecaf044593412c6271b58"><td class="memItemLeft" align="right" valign="top"><a id="a62f0b8e9500ecaf044593412c6271b58"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOT_STATE_ENTER</b>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:a62f0b8e9500ecaf044593412c6271b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c50cd2d01c2a92908b5820ae9d9720"><td class="memItemLeft" align="right" valign="top"><a id="a17c50cd2d01c2a92908b5820ae9d9720"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOT_STATE_ERROR</b>&#160;&#160;&#160;0x80</td></tr>
<tr class="separator:a17c50cd2d01c2a92908b5820ae9d9720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad4d0d5a96038d882593eac56794f70"><td class="memItemLeft" align="right" valign="top"><a id="aaad4d0d5a96038d882593eac56794f70"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOT_STATE_NB_ERROR</b>&#160;&#160;&#160;0x40</td></tr>
<tr class="separator:aaad4d0d5a96038d882593eac56794f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2922095e24d0bcdbe14f36875a7fdc2c"><td class="memItemLeft" align="right" valign="top"><a id="a2922095e24d0bcdbe14f36875a7fdc2c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOT_STATUS_OK</b>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:a2922095e24d0bcdbe14f36875a7fdc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434868841c8c53b1e0826be614186469"><td class="memItemLeft" align="right" valign="top"><a id="a434868841c8c53b1e0826be614186469"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOT_STATUS_INVALID_ADDRESS</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:a434868841c8c53b1e0826be614186469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2fde3cc10c8e86ea494c7b9425c667"><td class="memItemLeft" align="right" valign="top"><a id="aed2fde3cc10c8e86ea494c7b9425c667"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOT_STATUS_ERASE_ERROR</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:aed2fde3cc10c8e86ea494c7b9425c667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb57823f134b6a675acd22bcdc42fb6"><td class="memItemLeft" align="right" valign="top"><a id="a7bb57823f134b6a675acd22bcdc42fb6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOT_STATUS_PROG_ERROR</b>&#160;&#160;&#160;0x03</td></tr>
<tr class="separator:a7bb57823f134b6a675acd22bcdc42fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57918f97084378c0147f47ae51d36a99"><td class="memItemLeft" align="right" valign="top"><a id="a57918f97084378c0147f47ae51d36a99"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOT_STATUS_STATE_ERROR</b>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:a57918f97084378c0147f47ae51d36a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd43a1cdbed7509ae5b0aa832d716bc"><td class="memItemLeft" align="right" valign="top"><a id="acdd43a1cdbed7509ae5b0aa832d716bc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOT_STATUS_NB_ERROR</b>&#160;&#160;&#160;0x05</td></tr>
<tr class="separator:acdd43a1cdbed7509ae5b0aa832d716bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6cc014e6b15b7a1ba1801072e07d277"><td class="memItemLeft" align="right" valign="top"><a id="ae6cc014e6b15b7a1ba1801072e07d277"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOT_OPCODE_RESET</b>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:ae6cc014e6b15b7a1ba1801072e07d277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea60371d81c269e9c08e1113428e7c73"><td class="memItemLeft" align="right" valign="top"><a id="aea60371d81c269e9c08e1113428e7c73"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOT_OPCODE_SOFTSWAP</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:aea60371d81c269e9c08e1113428e7c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d68f636b1bd0a49eaeb1cf375c153d4"><td class="memItemLeft" align="right" valign="top"><a id="a7d68f636b1bd0a49eaeb1cf375c153d4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOT_OPCODE_VERIFY</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:a7d68f636b1bd0a49eaeb1cf375c153d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5baf664321d7da74cfe4488be88ead"><td class="memItemLeft" align="right" valign="top"><a id="aab5baf664321d7da74cfe4488be88ead"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOT_OPCODE_HARDSWAP</b>&#160;&#160;&#160;0x03</td></tr>
<tr class="separator:aab5baf664321d7da74cfe4488be88ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afd4a6162138d796e34cee4d8a2442596"><td class="memItemLeft" align="right" valign="top"><a id="afd4a6162138d796e34cee4d8a2442596"></a>
const char progname[32]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boot_8c.html#afd4a6162138d796e34cee4d8a2442596">__attribute__</a> ((section(&quot;.progname&quot;)))</td></tr>
<tr class="memdesc:afd4a6162138d796e34cee4d8a2442596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the chip. <br /></td></tr>
<tr class="separator:afd4a6162138d796e34cee4d8a2442596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57516d5955e696bf83e2915c7a8d1857"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boot_8c.html#a57516d5955e696bf83e2915c7a8d1857">check_nonbooting</a> ()</td></tr>
<tr class="memdesc:a57516d5955e696bf83e2915c7a8d1857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the program currently running is running from the non-booting bank.  <a href="boot_8c.html#a57516d5955e696bf83e2915c7a8d1857">More...</a><br /></td></tr>
<tr class="separator:a57516d5955e696bf83e2915c7a8d1857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ede44e2fb3943e5c88c0b87d17c1755"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boot_8c.html#a8ede44e2fb3943e5c88c0b87d17c1755">boot_state_machine</a> ()</td></tr>
<tr class="memdesc:a8ede44e2fb3943e5c88c0b87d17c1755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the current boot state and swap banks if needed.  <a href="boot_8c.html#a8ede44e2fb3943e5c88c0b87d17c1755">More...</a><br /></td></tr>
<tr class="separator:a8ede44e2fb3943e5c88c0b87d17c1755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2be0dfac3cabc71734c82636d313d87"><td class="memItemLeft" align="right" valign="top"><a id="ab2be0dfac3cabc71734c82636d313d87"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boot_8c.html#ab2be0dfac3cabc71734c82636d313d87">core_boot_reset_and_enter</a> ()</td></tr>
<tr class="memdesc:ab2be0dfac3cabc71734c82636d313d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the chip and enter the bootloader. <br /></td></tr>
<tr class="separator:ab2be0dfac3cabc71734c82636d313d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17df2565b3ec70a6a540f71a38bc4cdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="boot_8c.html#a17df2565b3ec70a6a540f71a38bc4cdc">core_boot_init</a> ()</td></tr>
<tr class="memdesc:a17df2565b3ec70a6a540f71a38bc4cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the FDCAN filters, check the boot state, and enter the bootloader if necessary. If the state is not valid, an error message will be transmitted.  <a href="boot_8c.html#a17df2565b3ec70a6a540f71a38bc4cdc">More...</a><br /></td></tr>
<tr class="separator:a17df2565b3ec70a6a540f71a38bc4cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Core bootloader. </p>
<p>This core library component implements a bootloader that allows boards to be programmed over CAN.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Theory of operation</h2>
<p>The STM32G473 cas 512k of FLASH, which is split into two banks of 256k each. The chip can be configured to boot either from the first or the second bank by configuring the non-volatile <code>BFB2</code> bit in the option byte registers. When the <code>BFB2</code> bit is set in the FLASH option byte register, the boots from the second bank, otherwise, it boots from the first bank. However, there is also an option to temporarily swap the banks and run the code in the second bank even when booting from the first bank. This allows the code in the non-booting bank to be verified before finalizing the swap. If the verification fails, then the chip will fall back to the working code in the booting bank.</p>
<p>Programming a board takes place according to the following process:</p><ol type="1">
<li>The programmer sends a command to the target board to enter the bootloader</li>
<li>The programmer sends program data to the target board. The target board writes the program data to the non-booting bank</li>
<li>After each block of data is written, the target board reads the block back so the programmer can verify it</li>
<li>Once all of the data has been written, the programmer commands the target board to switch to the non-booting bank</li>
<li>The target board board resets and performs a soft bank swap</li>
<li>The programmer commands the target board to enter the bootloader in the non-booting bank</li>
<li>The programmer sends a command to the bootloader in the non-booting bank to verify that FDCAN communication is working</li>
<li>The programmer commands the target board to binalize the bank swap</li>
<li>The target board updates the option byte, resets, and runs the new code</li>
</ol>
<p>The bootloader keeps track of its state across resets and between banks using the <code>boot_state</code> variable, which is stored at the highest RAM address (above the stack). This variable is not initialized when the chip is reset, so its value is always preserved unless the chip is power cycled. The highest 24 bits of <code>boot_state</code> are known as the boot key and must always be set to <code>0xABCDEF</code>. If the boot key is incorrect, an error is raised. This might occur if the <code>boot_state</code> variable is not correctly configured.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
FDCAN format</h2>
<p>The bootloader communicates with the programmer board using FDCAN with extended IDs. The extra bits in the ID are used to communicate they type of message and the address to be programmed (if required), so all 64 bytes in the body of the message can be used for data.</p>
<p>Each board has a unique board ID and master ID, so the master will respond to several IDs, one for each device that can be programmed. The 29-bit extended board IDs have the following format: </p><table class="doxtable RegisterTable">
<tr class="RegisterBitNumber">
<td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24 </td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16  </td></tr>
<tr class="RegisterFields">
<td colspan="3"></td><td colspan="11"><code>ID[10:0]</code> </td><td><span class="overlined">CTRL</span> </td><td><code>RD/</code><span class="overlined">WR</span>  </td></tr>
<tr class="RegisterBitNumber">
<td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8 </td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0  </td></tr>
<tr class="RegisterFields">
<td><code>PAD</code> </td><td colspan="15"><code>ADDR[14:0]</code>  </td></tr>
</table>
<ul>
<li><code>ID[10:0]</code>: slave ID, used for arbitration</li>
<li><span class="overlined">CTRL</span>: 0 for a control frame, 1 for a data frame</li>
<li><code>RD/</code><span class="overlined">WR</span>: 1 to read from the slave, 0 to write to the slave</li>
<li><code>PAD</code>: Set if the last doubleword in the frame is a padding doubleword</li>
<li><code>ADDR[14:0]</code>: Doubleword address</li>
</ul>
<p>The master IDs have the following format: </p><table class="doxtable RegisterTable">
<tr class="RegisterBitNumber">
<td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24 </td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16  </td></tr>
<tr class="RegisterFields">
<td colspan="3"></td><td colspan="11"><code>ID[10:0]</code> </td><td>1 </td><td><code>DATA/</code><span class="overlined">STAT</span>  </td></tr>
<tr class="RegisterBitNumber">
<td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8 </td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0  </td></tr>
<tr class="RegisterFields">
<td><code>PAD</code> </td><td colspan="15"><code>ADDR[14:0]</code>  </td></tr>
</table>
<ul>
<li><code>ID[10:0]</code>: master ID, used for arbitration</li>
<li><code>DATA/</code><span class="overlined">STAT</span>: 1 if the frame contains data (echo or read), 0 if the frame contains a status message</li>
<li><code>PAD</code>: Set if the last doubleword in the frame is a padding doubleword</li>
<li><code>ADDR[15:0]</code>: Doubleword address</li>
</ul>
<p>Status messages transmitted from a board to the programmer are 64 bits long and have the following format: </p><table class="doxtable RegisterTable">
<tr class="RegisterBitNumber">
<td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56 </td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48  </td></tr>
<tr class="RegisterFields">
<td colspan="8"><code>STATUS[7:0]</code> </td><td colspan="6"></td><td><code>BFB2</code> </td><td><code>MEMRMP</code>  </td></tr>
<tr class="RegisterBitNumber">
<td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40 </td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32  </td></tr>
<tr class="RegisterFields">
<td><code>OPTVERR</code> </td><td><code>RDERR</code> </td><td colspan="4"></td><td><code>FASTERR</code> </td><td><code>MISSERR</code> </td><td><code>PGSERR</code> </td><td><code>SIZERR</code> </td><td><code>PGAERR</code> </td><td><code>WRPERR</code> </td><td><code>PROGERR</code> </td><td></td><td><code>OPERR</code> </td><td><code>EOP</code>  </td></tr>
<tr class="RegisterBitNumber">
<td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24 </td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16  </td></tr>
<tr class="RegisterFields">
<td colspan="16"><code>BOOT_STATE_KEY[23:8]</code>  </td></tr>
<tr class="RegisterBitNumber">
<td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8 </td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0  </td></tr>
<tr class="RegisterFields">
<td colspan="8"><code>BOOT_STATE_KEY[7:0]</code> </td><td><code>ERROR</code> </td><td><code>NB_ERROR</code> </td><td></td><td><code>ENTER</code> </td><td><code>VERIFIED</code> </td><td><code>SOFT_SWITCHED</code> </td><td><code>VERIFY_SOFT_SWITCH</code> </td><td><code>VERIFY</code>  </td></tr>
</table>
<ul>
<li><code>STATUS[7:0]</code>: Status code <table class="doxtable">
<tr>
<td>0</td><td>No error </td></tr>
<tr>
<td>1</td><td>Address out of range </td></tr>
<tr>
<td>2</td><td>Error while erasing </td></tr>
<tr>
<td>3</td><td>Error while programming </td></tr>
<tr>
<td>4</td><td>Boot state error </td></tr>
<tr>
<td>5</td><td>Write from non-booting bank </td></tr>
</table>
</li>
<li><code>BFB2</code>: <code>BFB2</code> bit from the option byte register. Indicates which bank the chip will boot from</li>
<li><code>MEMRMP</code>: <code>MEMRMP</code> bit from the memory remap register. Indicates which bank is currently running</li>
<li>Next two bytes contain the lowest two bytes of <code>FLASH_SR</code></li>
<li>Next three bytes contain the boot key, which should be 0xABCDEF</li>
<li><code>ERROR</code>: Indicates a state error occurred in the booting bank</li>
<li><code>NB_ERROR</code>: Indicates a state error occurred in the non-booting bank</li>
<li><code>ENTER</code>: Indicates that the program should enter the bootloader after the next reset</li>
<li><code>VERIFIED</code>: Indicates that the program in the non-booting bank has been verified. If this bit is set, the banks can be swapped</li>
<li><code>SOFT_SWITCHED</code>: Indicates that the soft switching succeeded</li>
<li><code>VERIFY_SOFT_SWITCH</code>: Indicates that the signal to soft switch has been processed by the boot state machine in the booting bank</li>
<li><code>VERIFY</code>: Indicates that the chip should soft switch after the next reset</li>
</ul>
<h2><a class="anchor" id="autotoc_md4"></a>
Components</h2>
<p>The bootloader consists of four main components: the startup script, the boot state machine, the <a class="el" href="boot_8c.html#a17df2565b3ec70a6a540f71a38bc4cdc" title="Initialize the FDCAN filters, check the boot state, and enter the bootloader if necessary....">core_boot_init()</a> function, and an entry point.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
Startup script</h3>
<p>For the bootloader to work, the default startup script must be replaced by the startup script startup_stm32g473xx.s. The startup script defines the interrupt handlers for the program, including the reset handler. By default, the reset handler initializes the stack and jumps to the application code. The modified startup script required for the bootloader also runs the boot state machine before performing any additional initialization.</p>
<h3><a class="anchor" id="autotoc_md6"></a>
Boot state machine</h3>
<p>The boot state machine runs before any other code and updates the boot state or soft swaps as necessary. The BSM first checks the nature of the reset. If the reset was caused externally (by pulling the nRST pin low), then the state is reset to NORMAL and the BSM continues to the application code.</p>
<p>The behavior of the BSM depends on whether it is running in the booting or non-booting banks. In the booting bank, the BSM will change the state to VERIFY_SOFT_SWAP and soft-swap if the state is VERIFY and continue to application code otherwise.</p>
<p>In the non-booting bank, the BSM will change the state to SOFT_SWITCHED if the state is VERIFY_SOFT_SWAP. Otherwise, the BSM will set the NB_ERROR bit and reset. This causes the chip to return to the booting bank.</p>
<div class="image">
<object type="image/svg+xml" data="boot_state_machine.svg" style="pointer-events: none;"></object>
</div>
<h3><a class="anchor" id="autotoc_md7"></a>
core_boot_init()</h3>
<p>The <a class="el" href="boot_8c.html#a17df2565b3ec70a6a540f71a38bc4cdc" title="Initialize the FDCAN filters, check the boot state, and enter the bootloader if necessary....">core_boot_init()</a> function is called by application code after the clocks, GPIO, and FDCAN modules needed for the bootloader have been initialized. This function initializes the RX filter for the board's bootloader ID. The function also checks the boot state and enters the bootloader is necessary. See the state diagram above for details.</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Entry point</h3>
<p>The software enters the bootloader by calling <a class="el" href="boot_8c.html#ab2be0dfac3cabc71734c82636d313d87" title="Reset the chip and enter the bootloader.">core_boot_reset_and_enter()</a>. The FDCAN RX interrupt hander in <a class="el" href="can_8c.html" title="Core FDCAN library.">can.c</a> will automatically call this function if it receives a packet addressed to its bootloader FDCAN ID containing the command to enter the bootloader </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8ede44e2fb3943e5c88c0b87d17c1755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ede44e2fb3943e5c88c0b87d17c1755">&#9670;&nbsp;</a></span>boot_state_machine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boot_state_machine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process the current boot state and swap banks if needed. </p>
<p>This function is called from startup_stm32g473xx.s and is called before the HAL is initialized and before the RAM is initialized. The boot state is preserved in a special section (.bootstate) at the end of the RAM that is not initialized, so its contents are preserved between resets. </p>

</div>
</div>
<a id="a57516d5955e696bf83e2915c7a8d1857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57516d5955e696bf83e2915c7a8d1857">&#9670;&nbsp;</a></span>check_nonbooting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t check_nonbooting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the program currently running is running from the non-booting bank. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>The program currently running is in the booting bank </td></tr>
    <tr><td class="paramname">1</td><td>The program currently running is in the non-booting bank </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17df2565b3ec70a6a540f71a38bc4cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17df2565b3ec70a6a540f71a38bc4cdc">&#9670;&nbsp;</a></span>core_boot_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void core_boot_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the FDCAN filters, check the boot state, and enter the bootloader if necessary. If the state is not valid, an error message will be transmitted. </p>
<dl class="section note"><dt>Note</dt><dd>This function should be called after the FDCAN module is initialized. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
